
 libnuosc++ - A library for calculating 3 neutrino oscillation probabilities.

Introduction:
=============

This library provides various methods to calculate 3 neutrino
oscillation probabilities with and with out matter effects as well as
the possibility for a nonzero Dirac CP phase.  Anti neutrinos are also
handled.

It does this by solving the evolution equation:

	d(nu)/dx = [-i/(2E) U M^2 Udagger -iV] nu(x)

where U is the (potentially complex) mixing matrix, M^2 is
diag(0,dm^2_21,dm^2_31) and V = diag(A,0,0) is the matter effect term.
In the case of anti neutrinos the sign of A and of the CP phase is
inverted.

There are three classes of calculations with regards to matter
effects: vacuum oscillations in the absence of matter, oscillations
through constant density matter and a spherically symmetric earth
matter density profile from the Preliminary Reference Earth Model
(PREM) (see hep-ph/0002149 and http://solid_earth.ou.edu/prem.html).

For each of these three classes there are two methods of calculation.
A direct matrix transform method and a stepped method.  The matrix
transform involves analytically solving the evolution equation (see
hep-ph/9910546).  This solution is exact for the case of constant
density (and of course vacuum).

The second method is to step the evolution equation down the neutrino
baseline.  This is done with an 5th order adaptive Runge-Kutta
stepper.  Stepping in inherently non-exact, but the precision can be
controlled to arbitrary tightness at the cost of running time.  For
the vacuum or constant density cases the matrix methods are obviously
preferable.  In these cases, the step methods were developed for
checking, debugging and building up to the last class of calculation.

Since the earth density profile is not constant there is no analytical
solution so one must resort to some kind of approximation or to suffer
the running time needed for a full stepping of the evolution equation.
The approximation available is on based on the PREM with simplifying
assumptions.  First, it assumes each earth shell to have a constant
density equal to the average over the neutrino track through that
shell.  Second, when calculating the average the density as a function
of radius is assumed to be linear.  


Requirements:
=============

For the matrix calculations you will need a decent C++ compiler and
blitz++ (Debian package or from http://oonumerics.org/blitz/)

Implementation notes:
====================

The main interface are the functions in nuosc_prob.h.  There are 6
probability calculators covering the 3 matter effect possibilities
(vacuum, constant and PREM) times the 2 calculation methods (matrix
and step).  They are named like:

	nuosc_prob_[matter-type]_[calculation-type]()

With "matter-type" = "vacuum", "constant" or "prem" and
"calculation-type" = "matrix" or "step".

They take a ComplexVector (see matrix.h) holding the amplitude of the
initial neutrino, the oscilation parameters (bunded in OscParam, see
OscParam.h) as well as an energy and baseline.  Additionally, the
"constant" functions take a "density".  

Units are uniform throughout:

	[dm^2]		= eV^2
	[angle]		= radians
	[length]	= cm
	[energy]	= eV
	[density]	= g/cm^3

A note on anti-neutrinos: CP symetry is broken in that the matter
potential and the CP phase changes sign between neutrino and
anti-neutrino cases.  In the code this is handled inside by the
OscParam object via OscParam::set_antineutrino().  This unfortunately
mixes the idea of oscillation parameters (which are fundamental) with
the particular neutrino which is being evolved.  When asking OscParam
for a matrix via get_mixing_matrix() or get_matter_matrix() one will
have this -1 applied if using anti neutrinos.  However, the angle
returned via get_deltacp() will *NOT*.  When using these two matrices
for the evolution equation solution, one does not need to worry about
nu/antinu issues.  This is how nuosc_prob.cc functions behave.


Command line interface.
=======================

There exists a command line program, "genprob" (in main/) which gives
access to all these calculations.  Simply running it w/out any args
will produce this help:

usage: genprob [-e|--energy <energy> [GeV] default = 1 GeV]
               [-b|--baseline <baseline> [km] default = 1 km]
               [-E|--energy-range <Estart Estop Estep> [GeV] ...]
               [-B|--baseline-range <Bstart Bstop Bstep> [km] ...]
               [-t|--theta <theta_12 theta_23 theta_13> degrees ...]
               [-S|--sin <sin^2(2theta_12) sin^2(2theta_23) sin^2(2theta_13)> ...]
               [-s|--sol <dm2_sol = dm2_21 in eV^2> default = 5.0e-5 eV^2]
               [-a|--atm <dm2_atm = dm2_31 in eV^2> default = 2.5e-3 eV^2]
               [-d|--delta <CP phase in deg> default = 0]
               [-n|--neutrino <nu number> nue=1,numu=2,nutau=3, anti *= -1]
               [-D|--density <constant density in g/cm^3> default = 0. <0 => PREM]
               [-c|--calculation <calculation type> "matrix"(def), "step"] 

Note that the units are different ([angle]=degrees, [energy]=GeV,
[distance]=km) than the underlying code uses and are given in the help
message.

The ouput is 

	<energy> <baseline> <P(nux->nue)> <P(nux->numu)> <P(nux->nutau)>

If one uses -e a single energy will be calculated and with -E, a range
of energies will be calculated with one line of output per energy.
Similarly a single baseline is specified with -b and a range with -B.

Either mixing angles or the corresponding sin^2(2theta)'s can be
specified.  Internally angles are used.  Default is SK atmospheric
best fit point, LMA and CHOOZ limit at SK best fit point.

The initial neutrino is specified as nue=1, numu=2 and nutau=3.  The
same is used for anti-neutrino but with the sign inverted.

The density (in g/cm^3) can be negative in order to use PREM, 0 for
vacuum or positive for constant density.

The calculation method (see above) can be either "matrix" or "step".

